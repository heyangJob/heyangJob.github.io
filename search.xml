<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式开篇《六大原则》]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87%E3%80%8A%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E3%80%8B%2F</url>
    <content type="text"><![CDATA[目录&emsp;&emsp;创建型模式 单例模式 工厂方法模式 抽象工厂模式 原型模式 建造者模式 &emsp;&emsp;结构型模式 代理模式 适配器模式 装饰模式 桥接模式 组合模式 享元模式 外观模式 &emsp;&emsp;行为型模式 模板方法模式 策略模式 状态模式 观察者模式 责任链模式 中介者模式 备忘录模式 命令模式 解释器模式 访问者模式 迭代器模式 一、单一职责原则定义&emsp;&emsp;一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。简单来说，一个类中应该是一组相关性很高的函数、数据的封装。 1. 一般我们写一个网络请求可能是这样123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class HttpUtils &#123; private HttpUtils() &#123; &#125; public static &lt;T&gt; void get(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback, final boolean cache) &#123; OkHttpClient mOkHttpClient = new OkHttpClient(); // 公共参数 params.put(&quot;app_name&quot;, &quot;joke_essay&quot;); params.put(&quot;version_name&quot;, &quot;5.7.0&quot;); params.put(&quot;device_platform&quot;, &quot;android&quot;); final String jointUrl = Utils.jointParams(url, params); //打印 // 缓存问题 Log.e(&quot;Post请求路径：&quot;, jointUrl); // 缓存写到 SP 里面，多级缓存（内存中 30条,数据库 ，文件中 ） final String cacheJson = (String) PreferencesUtil.getInstance().getParam(jointUrl, &quot;&quot;); // 写一大堆处理逻辑 ，内存怎么扩展等等 if (cache &amp;&amp; !TextUtils.isEmpty(cacheJson)) &#123; Log.e(&quot;TAG&quot;, &quot;从缓存中获取数据&quot;); Gson gson = new Gson(); T objResult = (T) gson.fromJson(cacheJson, Utils.analysisClazzInfo(callback)); callback.onSuccess(objResult); return; &#125; Request.Builder requestBuilder = new Request.Builder().url(jointUrl).tag(context); //可以省略，默认是GET请求 Request request = requestBuilder.build(); mOkHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, final IOException e) &#123; // 失败 callback.onFailure(e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; final String resultJson = response.body().string(); Log.e(&quot;TAG&quot;, resultJson.equals(cacheJson) + &quot;&quot;); Log.e(&quot;TAG&quot;, resultJson + &quot;&quot;); if (cache &amp;&amp; resultJson.equals(cacheJson)) &#123; return; &#125; Gson gson = new Gson(); T objResult = (T) gson.fromJson(resultJson, Utils.analysisClazzInfo(callback)); callback.onSuccess(objResult); if (cache) &#123; PreferencesUtil.getInstance().saveParam(jointUrl, resultJson); &#125; &#125; &#125;); &#125;&#125; 2. 然后这样调用1234567891011121314151617181920212223Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); // 特定参数 params.put(&quot;iid&quot;, 6152551759L); params.put(&quot;aid&quot;, 7); HttpUtils.get(this, ConstantValue.UrlConstant.HOME_DISCOVERY_URL, params, new HttpCallBack&lt;DiscoverListResult&gt;() &#123; @Override public void onFailure(Exception e) &#123; // 失败 &#125; @Override public void onSuccess(DiscoverListResult result)&#123; if (result.isOK()) &#123; // 没有列表数据的情况, 打印 Toast 或者做一些其他处理 &#125; else &#123; // 有数据列表的情况，显示列表 showListData(result); &#125; &#125; &#125;,true); 3. 导致问题&emsp;&emsp;所有的功能都写在一个类里，这样随着功能的增多，HttpUtils 类会越来越大，代码也越来越复杂。HttpUtils简直就没有设计可言，更不要说扩展性、灵活性了。 4. 单一职责原则入场&emsp;&emsp;我们将HttpUtils进行拆分，一个类只负责一个职责。 5. HttpUtils123456789101112131415public class HttpUtils &#123; private OKHttpRequest mHttpRequest; public &lt;T&gt; void request() &#123; request(null); &#125; public &lt;T&gt; void request(final HttpCallBack&lt;T&gt; callback) &#123; // 异常判断 mHttpRequest.get(mContext, mUrl, mParams, callback, true); &#125; //省略其他代码&#125; 6. OKHttpRequest12345678910111213141516public class OKHttpRequest &#123; private HttpCache mHttpCache; public OKHttpRequest() &#123; mHttpCache = new HttpCache(); &#125; // 参数还是很多 public &lt;T&gt; void get(Context context, String url, Map&lt;String, Object&gt; params,final HttpCallBack&lt;T&gt; callback, final boolean cache) &#123; OkHttpClient mOkHttpClient = new OkHttpClient(); &#125; //省略其他代码&#125; 7. HttpCache123456789public class HttpCache &#123; public void saveCache(String finalUrl, String resultJson) &#123; PreferencesUtil.getInstance().saveParam(finalUrl, resultJson); &#125; public String getCache(String finalUrl) &#123; return (String) PreferencesUtil.getInstance().getParam(finalUrl, &quot;&quot;); &#125;&#125; 二、开闭原则定义&emsp;&emsp;软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的。我的理解是对于原来写好的代码里面是不可修改，但是对于外部又是可扩展的。其实就是多了一个接口而已。 1. 上面代码存在问题&emsp;&emsp;如果把xutils换成OkHttp，但是我没想过要去改每个接口，比如后来接着 Retrofit又出来了，以后还指不定要出一些什么，我想能不能再写得强大一些，可以切换，而不用改动原来的代码。 2. 修改后的类图 3. 开闭原则入场&emsp;&emsp;新增IHttpRequest接口123456789101112131415161718/** * @author 512573717@qq.com * @created 2018/8/22 上午10:49. */public interface IHttpRequest &#123; &lt;T&gt; void get(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback, final boolean cache); &lt;T&gt; void post(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback, final boolean cache); &lt;T&gt; void download(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback); &lt;T&gt; void upload(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback);&#125; 4. XUtilsRequest123456789101112131415public class XUtilsRequest implements IHttpRequest &#123; private SPHttpCache mHttpCache; public XUtilsRequest() &#123; mHttpCache = new SPHttpCache(); &#125; // 参数还是很多 public &lt;T&gt; void get(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback, final boolean cache) &#123; RequestParams requestParams = new RequestParams(); x.http().get(requestParams, new org.xutils.common.Callback.CommonCallback&lt;String&gt;() &#123; &#125;); &#125; 5. OKHttpRequest123456789101112131415public class OKHttpRequest implements IHttpRequest&#123; private SPHttpCache mHttpCache; public OKHttpRequest() &#123; mHttpCache = new SPHttpCache(); &#125; // 参数还是很多 public &lt;T&gt; void get(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback, final boolean cache) &#123; OkHttpClient mOkHttpClient = new OkHttpClient(); &#125;&#125; 6. HttpUtils1234567891011121314151617181920212223242526public class HttpUtils &#123; private IHttpRequest mHttpRequest; private static IHttpRequest mInitHttpRequest; public static HttpUtils with(Context context)&#123; return new HttpUtils(context); &#125; public HttpUtils httpRequest(IHttpRequest httpRequest)&#123; mHttpRequest = httpRequest; return this; &#125; public &lt;T&gt; void request()&#123; request(null); &#125; public &lt;T&gt; void request(final HttpCallBack&lt;T&gt; callback)&#123; if(mHttpRequest == null)&#123; mHttpRequest = mInitHttpRequest; &#125; // 异常判断 mHttpRequest.get(mContext,mUrl,mParams,callback,true); &#125; &#125; 7. Client12345678910111213141516171819HttpUtils.with(this).cache(true).get().httpRequest(new OKHttpRequest()).url(ConstantValue.UrlConstant.HOME_DISCOVERY_URL).param(&quot;iid&quot;, 6152551759L).param(&quot;aid&quot;, 7).request( new HttpCallBack&lt;DiscoverListResult&gt;() &#123; @Override public void onFailure(Exception e) &#123; // 失败 &#125; @Override public void onSuccess(DiscoverListResult result)&#123; if (result.isOK()) &#123; // 没有列表数据的情况, 打印 Toast 或者做一些其他处理 &#125; else &#123; // 有数据列表的情况，显示列表 showListData(result); &#125; &#125; &#125;); 8. 归纳&emsp;&emsp;当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。我们尽量不要通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。 三、里氏替换原则定义&emsp;&emsp;所有引用基类的地方必须能透明地使用其子类的对象。通俗点讲，只要父类能出现的地方子类就可以出现。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。 代码体现12HttpUtils.initHttpRequest(new OKHttpRequest());HttpUtils.initHttpRequest(new XUtilsRequest()); 四、依赖倒置原则定义&emsp;&emsp;依赖反转原则指代了一种特定的解耦形式，高层模块不依赖低层次模块的细节，说白了高层次就是不依赖细节而是依赖抽象。 1. 刚开始代码是这样写的123456789public class HttpUtils &#123; private OKHttpRequest mHttpRequest; private HttpUtils(Context context) &#123; mHttpRequest = new OKHttpRequest(); mParams = new HashMap&lt;&gt;(); this.mContext = context; &#125;&#125; 2. 用过开闭原则之后是这样写的123456789101112public class HttpUtils &#123; private IHttpRequest mHttpRequest; public static HttpUtils with(Context context)&#123; return new HttpUtils(context); &#125; public HttpUtils httpRequest(IHttpRequest httpRequest)&#123; mHttpRequest = httpRequest; return this; &#125;&#125; 3. 总结&emsp;&emsp;这个时候我们依赖的就已经不在是具体的细节了，而是抽象的 IHttpRequest ，具体的实现我们是在 Application 中配置的，可以配置 Okhttp 或者 xUtils 等等。从上面这几个来看要让整个系统更加灵活，似乎一直都是抽象的功劳。 五、接口隔离原则定义&emsp;&emsp;客户端不应该依赖它不需要的接口。另一种定义是：类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署，让客户端依赖的接口尽可能地小。 1. 我们在关闭文件流、Socket流通常是这样操作的12345678910111213141516171819202122232425262728private void breakConnection() &#123; mReadFlag = false; // 关闭输入流 if (mInStream != null) &#123; try &#123; mInStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 关闭输出流 if (mOutStream != null) &#123; try &#123; mOutStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 关闭Socket if (mSocket != null) &#123; try &#123; mSocket.close(); mSocket = null; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &emsp;&emsp;各种try…catch嵌套，都是些简单的代码，但是会严重影响代码的可读性，并且多层级的大括号很容易将代码写到错误的层级中。大家应该对这类代码也非常反感，那我们看看如何解决这类问题。我们看源码发现他们都有一个 close 方法，而且这个方法是 Closeable 接口的，也就是说上面的这几个类都是实现了 Closeable 接口，该接口标识了一个可关闭的对象。 2.都实现了Closeable接口1234567891011public abstract class InputStream implements Closeable &#123; &#125;public abstract class OutputStream implements Closeable, Flushable &#123; &#125;public class Socket implements java.io.Closeable &#123; &#125; 3. Closeable1234567891011121314151617public interface Closeable extends AutoCloseable &#123; /** * Closes this stream and releases any system resources associated * with it. If the stream is already closed then invoking this * method has no effect. * * &lt;p&gt; As noted in &#123;@link AutoCloseable#close()&#125;, cases where the * close may fail require careful attention. It is strongly advised * to relinquish the underlying resources and to internally * &lt;em&gt;mark&lt;/em&gt; the &#123;@code Closeable&#125; as closed, prior to throwing * the &#123;@code IOException&#125;. * * @throws IOException if an I/O error occurs */ public void close() throws IOException;&#125; 4. 修改代码1234567891011121314151617181920212223private void breakConnection() &#123; mReadFlag = false; // 关闭输入流 close(mInStream); // 关闭输出流 close(mOutStream); // 关闭Socket close(mSocket);&#125;/*** 关闭 Closeable* @param closeable*/private void close(Closeable closeable) &#123; if (closeable != null) &#123; try &#123; closeable.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5. 总结&emsp;&emsp;代码简洁了很多！保证了代码的重用性。close 方法的基本原理就是依赖于 Closeable 抽象而不是具体实现（这其实也是依赖倒置），并且建立在最小化依赖原则的基础，它只需要知道这个对象是可关闭，其他的一概不关心，也就是这里的接口隔离原则。 六、最少知识原则定义&emsp;&emsp;一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 示例地址&emsp;&emsp;Demo]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
</search>
