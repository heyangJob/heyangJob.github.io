<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式《模板方法模式》]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[引言&emsp;&emsp;上一节我们说了抽象工厂模式，今天我们来说说”模板方法模式”。 示例地址&emsp;&emsp;Demo 依然是先看类图 模板方法模式的定义&emsp;&emsp;定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使的子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 使用场景&emsp;&emsp;1. 多个子类有公有的方法，并且逻辑基本相同时。&emsp;&emsp;2. 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则有各个子类实现。&emsp;&emsp;3. 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。 模板方法模式示例&emsp;&emsp;每到年底，在北京的外地人都要回家，很多人选择做火车回家，也有选择坐飞机回去的。但是他们都经历同样的过程。买票、上车（登机）、下车、回家。 1. 首先，我们来写基类1234567891011121314151617181920/** * 春节回家的基类 * * @author 512573717@qq.com * @created 2018/7/10 下午3:03. */public abstract class BaseGoHome &#123; //选择出行方式 public abstract void travelWay(); //买票 public abstract void buyTicket(); //上车 public abstract void shangche(); //下车 public abstract void xiache();&#125; 2. 看看老王怎么回家的123456789101112131415161718192021222324252627/** * 老王回家 * * @author 512573717@qq.com * @created 2018/7/10 下午3:11. */public class LaoWang extends BaseGoHome &#123; @Override public void travelWay() &#123; System.out.println(&quot;选择做火车回家&quot;); &#125; @Override public void buyTicket() &#123; System.out.println(&quot;去火车站买票&quot;); &#125; @Override public void shangche() &#123; System.out.println(&quot;在候车室检票进站&quot;); &#125; @Override public void xiache() &#123; System.out.println(&quot;下车 做公交回家&quot;); &#125;&#125; 3. 在看看小明的123456789101112131415161718192021222324252627/** * 小明回家 * * @author 512573717@qq.com * @created 2018/7/10 下午3:10. */public class XiaoMing extends BaseGoHome &#123; @Override public void travelWay() &#123; System.out.println(&quot;选择做飞机回家&quot;); &#125; @Override public void buyTicket() &#123; System.out.println(&quot;在网上买提前订票&quot;); &#125; @Override public void shangche() &#123; System.out.println(&quot;换登记牌 登机&quot;); &#125; @Override public void xiache() &#123; System.out.println(&quot;打车回家&quot;); &#125;&#125; 4. 具体运用12345678910111213System.out.println(&quot;小明春节回家&quot;);BaseGoHome xiaoming = new XiaoMing();xiaoming.travelWay();xiaoming.buyTicket();xiaoming.shangche();xiaoming.xiache();System.out.println(&quot;老王春节回家&quot;);BaseGoHome laowang = new XiaoMing();laowang.travelWay();laowang.buyTicket();laowang.shangche();laowang.xiache(); 总结&emsp;&emsp;模板方法模式，我们用的应该是比较多的，例如BaseActivity、BaseFragment。Android源码的Activity是一个典型的模板方法模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式《抽象工厂模式》]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[引言&emsp;&emsp;上一回怎么说了工厂方法模式，这回咱们来讲一讲工厂模式的另外一种表现，今天的主角”抽象工厂模式”。 示例地址&emsp;&emsp;Demo 先上类图 看看定义&emsp;&emsp;为创建一组相关或者相互依赖的对象提供一个接口，而不需要指定它们的具体类。 使用场景&emsp;&emsp;一个对象族有相同的约束时可以使用抽象工厂模式。 抽象工厂中的2个概念产品族&emsp;&emsp;位于不同产品等级结构中，功能相关联的产品组成的家族。代表的是纵向结构。&emsp;&emsp;举个例子,华为有华为笔记本，华为手机，华为手环等，小米也有小米手机，小米笔记本，小米手环。华为这个系列的构成了家族。称为产品族。 产品等级&emsp;&emsp;产品等级结构即产品的继承结构。代表的是横向结构。&emsp;&emsp;举个列子，一个抽象类手机，下面可以生成小米手机、华为手机。 产品族与产品等级图 产品类1. 手机12345678910111213141516171819202122232425262728293031323334353637/** * 手机 * * @author 512573717@qq.com * @created 2018/7/9 上午10:19. */public interface IPhone &#123; void phone();&#125;/** * 小米手机 * * @author 512573717@qq.com * @created 2018/7/9 上午10:25. */public class XiaomiPhone implements IPhone &#123; @Override public void phone() &#123; System.out.println(&quot;小米手机&quot;); &#125;&#125;/** * 华为手机 * * @author 512573717@qq.com * @created 2018/7/9 上午10:23. */public class HuaweiPhone implements IPhone &#123; @Override public void phone() &#123; System.out.println(&quot;华为手机&quot;); &#125;&#125; 2. 笔记本12345678910111213141516171819202122232425262728293031323334353637/** * 笔记本 * * @author 512573717@qq.com * @created 2018/7/9 上午10:27. */public interface IComputer &#123; void computer();&#125;/** * 小米笔记本 * * @author 512573717@qq.com * @created 2018/7/9 上午10:44. */public class XiaomiComputer implements IComputer &#123; @Override public void computer() &#123; System.out.println(&quot;小米笔记本&quot;); &#125;&#125;/** * 华为笔记本 * * @author 512573717@qq.com * @created 2018/7/9 上午10:37. */public class HuaweiComputer implements IComputer &#123; @Override public void computer() &#123; System.out.println(&quot; 华为笔记本&quot;); &#125;&#125; 3. 手环12345678910111213141516171819202122232425262728293031323334353637/** * 手环 * * @author 512573717@qq.com * @created 2018/7/9 上午10:55. */public interface IBracelet &#123; void bracelet();&#125;/** * 小米手环 * * @author 512573717@qq.com * @created 2018/7/9 上午10:59. */public class XiaomiBracelet implements IBracelet &#123; @Override public void bracelet() &#123; System.out.println(&quot;小米手环&quot;); &#125;&#125;/** * 华为手环 * * @author 512573717@qq.com * @created 2018/7/9 上午10:57. */public class HuaweiBracelet implements IBracelet &#123; @Override public void bracelet() &#123; System.out.println(&quot;华为手环&quot;); &#125;&#125; 4. 工厂类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 抽象工厂 * @author 512573717@qq.com * @created 2018/7/9 上午10:16. */public abstract class ProductFactory &#123; // 创建手机 public abstract IPhone createPhone(); // 创建笔记本 public abstract IComputer createComputer(); // 创建手环 public abstract IBracelet createBracelet();&#125;/** * 小米 * * @author 512573717@qq.com * @created 2018/7/9 上午11:09. */public class Xiaomi extends ProductFactory &#123; @Override public IPhone createPhone() &#123; return new XiaomiPhone(); &#125; @Override public IComputer createComputer() &#123; return new XiaomiComputer(); &#125; @Override public IBracelet createBracelet() &#123; return new XiaomiBracelet(); &#125;&#125;/** * 华为 * * @author 512573717@qq.com * @created 2018/7/9 上午11:03. */public class Huawei extends ProductFactory &#123; @Override public IPhone createPhone() &#123; return new HuaweiPhone(); &#125; @Override public IComputer createComputer() &#123; return new HuaweiComputer(); &#125; @Override public IBracelet createBracelet() &#123; return new HuaweiBracelet(); &#125;&#125; 5. Client测试12345678910111213//华为系列System.out.println(&quot;华为&quot;);ProductFactory huawei = new Huawei();huawei.createPhone().phone();huawei.createComputer().computer();huawei.createBracelet().bracelet();//小米系列System.out.println(&quot;小米&quot;);ProductFactory xiaomi=new Xiaomi();xiaomi.createPhone().phone();xiaomi.createComputer().computer();xiaomi.createBracelet().bracelet(); 总结&emsp;&emsp;抽象工厂模式是某一系列的产品的工厂。可以创建多个不同类型的产品。例如上面所说的 华为是一个产品工厂，能够创建手机 、笔记本、手机等多个类型的产品。 抽象工厂 与工厂方法的区别&emsp;&emsp;工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式《工厂方法模式》]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[引言&emsp;&emsp;上一节我们说了单例模式，这一节我们来说说工厂方法模式。 示例地址&emsp;&emsp;Demo 先看类图 工厂方法模式定义&emsp;&emsp;定义一个用于创建对象的接口，让子类决定实例化哪一个类。 使用场景&emsp;&emsp;在任何需要生成复制对象的地方，都可以使用工厂方法模式。 工厂方法模式示例&emsp;&emsp;举个例子，我们吃饭的时候都会点主食，主食的种类分为 米饭、面,南方人喜欢吃米饭，但是北方人喜欢吃面。 简单工厂模式1. 我们先来设计产品12345678910/** * 主食 * @author 512573717@qq.com * @created 2018/7/6 下午2:36. * */public interface IZhuShi &#123; // 主食吃什么 void eat();&#125; 2. 产品一:南方人爱吃米饭12345678910111213/** * 主食米饭 * * @author 512573717@qq.com * @created 2018/7/6 下午2:37. * */public class Rice implements IZhuShi &#123; @Override public void eat() &#123; System.out.println(&quot;主食米饭上来了。&quot;); &#125;&#125; 3. 产品二:北方人爱吃面食123456789101112/** * 主食面 * * @author 512573717@qq.com * @created 2018/7/6 下午2:43. */public class Flour implements IZhuShi &#123; @Override public void eat() &#123; System.out.println(&quot;主食 面上来了。&quot;); &#125;&#125; 简单（静态）工厂&emsp;&emsp;接下来是我们怎么创建产品了,就是我们在点餐的时候要选择吃什么。 1. 主食工厂1234567891011121314151617181920212223/** * 主食工厂 * * @author 512573717@qq.com * @created 2018/7/6 下午2:48. */public class FactoryZhuShi &#123; //南方人 public static final int SOUTH = 1; //北方人 public static final int NORTH = 2; public static IZhuShi createZhuShi(int type) &#123; switch (type) &#123; case SOUTH: return new Rice(); case NORTH: return new Flour(); default: return new Rice(); &#125; &#125;&#125; 2. 调用工厂创建产品12345IZhuShi south = FactoryZhuShi.createZhuShi(FactoryZhuShi.SOUTH);south.eat();IZhuShi north = FactoryZhuShi.createZhuShi(FactoryZhuShi.NORTH);north.eat(); 3. 如果我们增加了产品三(水饺)，这个时候就需要修改工程类了，违背了设计模式的六大原则（开闭原则）。简单（反射）工厂&emsp;&emsp;Java中反射是无所不能的。那我们就反一种思路，我们通过反射实现。 1. 反射实现工厂12345678910111213141516171819202122/** * 通过反射获取主食 * * @author 512573717@qq.com * @created 2018/7/6 下午3:11. */public class ReflectFactoryZhuShi &#123; public static &lt;T extends IZhuShi&gt; T createZhuShi(Class&lt;T&gt; cls) &#123; T object = null; try &#123; object = (T) (Class.forName(cls.getName())).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return object; &#125;&#125; 2. 调用工厂创建产品12345IZhuShi south = ReflectFactoryZhuShi.createZhuShi(Rice.class);south.eat();IZhuShi north = ReflectFactoryZhuShi.createZhuShi(Flour.class);north.eat(); 3. 在增加新产品的时候，我们无需修改工厂类，解决设计模式的开闭原则。但是反射影响性能，我们在来看看方法工厂模式简单工厂&emsp;&emsp;反射有效率问题，我们看看最常用的一种写法 1. 日常写法12345678910111213141516/** * 简单工厂 * * @author 512573717@qq.com * @created 2018/7/6 下午3:37. */public class MethodFactoryZhuShi &#123; public static Rice getRice() &#123; return new Rice(); &#125; public static Flour getFlour() &#123; return new Flour(); &#125;&#125; 2. 简单调用12345IZhuShi south = MethodFactoryZhuShi.getRice();south.eat();IZhuShi north = MethodFactoryZhuShi.getFlour();north.eat(); 工厂方法模式1. 工厂接口123456789/** * 主食创建工厂 * * @author 512573717@qq.com * @created 2018/7/6 下午4:08. */public interface IFactory&lt;T extends IZhuShi&gt; &#123; T create();&#125; 2. 米饭工厂12345678910111213/** * 米饭工厂 * * @author 512573717@qq.com * @created 2018/7/8 下午11:11. * */public class RiceFactory implements IFactory&lt;Rice&gt; &#123; @Override public Rice create() &#123; return new Rice(); &#125;&#125; 3. 面食工厂12345678910111213/** * 面食工厂 * * @author 512573717@qq.com * @created 2018/7/8 下午11:11. * */public class FlourFactory implements IFactory&lt;Flour&gt; &#123; @Override public Flour create() &#123; return new Flour(); &#125;&#125; 4. 简单调用1234567IFactory northFactory = new FlourFactory();IZhuShi north = northFactory.create();north.eat();IFactory southFactory = new RiceFactory();IZhuShi south = southFactory.create();south.eat(); 总结&emsp;&emsp; 当有新的产品产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代码。（即当有新产品时，只要创建并基础抽象产品；新建具体工厂继承抽象工厂；而不用修改任何一个类）工厂方法模式是完全符合开闭原则的！]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式《解释器模式》]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[引言&emsp;&emsp;看到这个模式，第一反应是我没见过。在看看定义，太抽象了，所以放到后面写。首先我们先看看上一节命令模式，继续学学这节的解释器模式。 示例地址&emsp;&emsp;Demo（simple2 感觉不是很好的说明解释器模式） 类图 定义&emsp;&emsp;定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。 使用场景&emsp;&emsp;1. 如果某个简单的语言需要解释执行而且可以将该语言中的语句表叔为一个抽象语法树时可以考虑使用解释器模式。&emsp;&emsp;2. 在某些特定的领域出现不断重复的问题时，可以将该领域的问题转化为一种语法规则下的语句，然后构建解释器来解释该语句。 解释器模式中的概念词文法规则：&emsp;&emsp;一种简单的语言定义。例如表达”1+ 2 + 3 – 4 + 1”. expression = value | operationoperation = ‘+’ | ‘-‘value = an integer //一个整数值 其中整个语句为表达式。表达式有 单一的表达式、复合的表达式（多个单一的表达式组合而成，通过非终结符操作），”+” | “-“为非终结符。value 为终结符。 抽象语法树&emsp;&emsp;例如表达”1+ 2 + 3 – 4 + 1”.从下往上看。 终结符表达式：&emsp;&emsp;比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。 非终结符表达式&emsp;&emsp;比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。 Context（环境类）&emsp;&emsp;环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。 解释器模式简单示例&emsp;&emsp;也许上面的你没看懂，下面我们通过代码来展示上面“1+ 2 + 3 – 4 + 1”的含义。 1. 抽象解析类123456789/** * 抽象解析类 * * @author 512573717@qq.com * @created 2018/8/14 下午5:13. */public abstract class AbstractExpression &#123; public abstract int interpret();&#125; 2. 数字的实现（终结符表达式）123456789101112131415161718/** * 数字解释器 * * @author 512573717@qq.com * @created 2018/8/14 下午5:16. */public class NumExpression extends AbstractExpression &#123; private int num; public NumExpression(int num) &#123; this.num = num; &#125; @Override public int interpret() &#123; return num; &#125;&#125; 3. 操作符的实现（非终结符表达式）1234567891011121314151617181920/** * 运算符号抽象解释器 * * @author 512573717@qq.com * @created 2018/8/15 上午11:47. */public class OperationExpression extends AbstractExpression &#123; //声明两个成员变量存储运算符号两边的数字解释器 protected AbstractExpression exp1, exp2; public OperationExpression(AbstractExpression exp1, AbstractExpression exp2) &#123; this.exp1 = exp1; this.exp2 = exp2; &#125; @Override public int interpret() &#123; return 0; &#125;&#125; 4. 加法运算抽象解释器12345678910111213141516/** * 加法运算抽象解释器 * * @author 512573717@qq.com * @created 2018/8/15 下午11:10. */public class AddExpression extends OperationExpression &#123; public AddExpression(AbstractExpression exp1, AbstractExpression exp2) &#123; super(exp1, exp2); &#125; @Override public int interpret() &#123; return exp1.interpret() + exp2.interpret(); &#125;&#125; 5. 减法运算抽象解释器12345678910111213141516/** * 减法运算抽象解释器 * * @author 512573717@qq.com * @created 2018/8/15 下午11:10. */public class SubExpression extends OperationExpression &#123; public SubExpression(AbstractExpression exp1, AbstractExpression exp2) &#123; super(exp1, exp2); &#125; @Override public int interpret() &#123; return exp1.interpret() - exp2.interpret(); &#125;&#125; 6. 处理与解释相关的一些业务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 处理与解释相关的一些业务 * * @author 512573717@qq.com * @created 2018/8/15 下午11:12. * */public class Calculator &#123; //声明一个Stack栈存储并操作所有相关的解释器 private Stack&lt;AbstractExpression&gt; expressions = new Stack&lt;AbstractExpression&gt;(); public Calculator(String expression) &#123; //声明两个ArithmeticExpressioin类型的临时变量，存储运算符左右两边的数字解释器 AbstractExpression exp1, exp2; String[] elements = expression.split(&quot; &quot;); for (int i = 0; i &lt; elements.length; i++) &#123; switch (elements[i].charAt(0)) &#123; case &apos;+&apos;: //将栈中的解释器弹出作为运算符号左边的解释器 exp1 = expressions.pop(); //同时将运算符号数组角标下一个元素构成 exp2 = new NumExpression(Integer.valueOf(elements[++i])); //通过上面两个数字解释器构造加法运算解释器 expressions.push(new AddExpression(exp1, exp2)); break; case &apos;–&apos;: //将栈中的解释器弹出作为运算符号左边的解释器 exp1 = expressions.pop(); //同时将运算符号数组角标下一个元素构成 exp2 = new NumExpression(Integer.valueOf(elements[++i])); //通过上面两个数字解释器构造加法运算解释器 expressions.push(new SubExpression(exp1, exp2)); break; default://如果为数字 /** * 如果不是运算符则数字 * 则是数字，直接构造数字解释器并压入栈 */ expressions.push(new NumExpression(Integer.valueOf(elements[i]))); break; &#125; &#125; &#125; /** * 计算 * @return */ public int calculate() &#123; return expressions.pop().interpret(); &#125;&#125; 7. Client12Calculator calculator = new Calculator(&quot;1 + 2 + 3 – 4 + 1&quot;);System.out.println(calculator.calculate()); 总结优点&emsp;&emsp;1. 灵活的扩展性，当我们想对文法规则进行扩展时，只需要增加相应的非终结符号解释器，并在构建抽象语法树时，使用到新增的解释器对象进行具体的解释即可，非常方便。 缺点&emsp;&emsp; 1. 过于复杂的语法，构建其抽象语法树会显得异常繁琐，甚至有可能出现需要构建多棵抽象语法树的情况，因此，对于复杂的文法并不推荐使用解释器模式。&emsp;&emsp;2. 对于每一条文法都可以对应至少一个解释器，其会生成大量的类，导致后期维护困难。&emsp;&emsp;3. 由于使用了大量的循环和递归，效率是个不容忽视的问题，特别是用于解析复杂、冗长的语法时，效率是难以忍受的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式《访问者模式》]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[引言&emsp;&emsp;23设计模式这是最后一篇了，到此就结尾了，先回顾一下上一篇所讲的解释器模式，然后看看今天的访问者模式。 示例地址&emsp;&emsp;Demo 类图 定义&emsp;&emsp;封装一些作用于某些数据结构的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。 使用场景&emsp;&emsp;1. 对象结构比较稳定，但经常需要在此对象结构上定义新的操作。&emsp;&emsp;2. 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。 访问者模式中的角色&emsp;&emsp;1. Vistor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。&emsp;&emsp;2. ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。&emsp;&emsp;3. Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数。&emsp;&emsp;4. ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作。&emsp;&emsp;5. ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象。 访问者模式示例1. Visitor抽象类12345678/** * @author 512573717@qq.com * @created 2018/8/20 上午10:35. */public interface Visitor &#123; void visit(ConcreteElementA elementA); void visit(ConcreteElementB elementB);&#125; 2. Visitor实现类ConcreteVisitorA1234567891011121314151617/** * @author 512573717@qq.com * @created 2018/8/20 上午10:36. */public class ConcreteVisitorA implements Visitor &#123; @Override public void visit(ConcreteElementA elementA) &#123; &#125; @Override public void visit(ConcreteElementB elementB) &#123; &#125;&#125; 3. Visitor实现类ConcreteVisitorB123456789101112131415/** * @author 512573717@qq.com * @created 2018/8/20 上午10:36. */public class ConcreteVisitorB implements Visitor &#123; @Override public void visit(ConcreteElementA elementA) &#123; &#125; @Override public void visit(ConcreteElementB elementB) &#123; &#125;&#125; 4. Element接口1234567/** * @author 512573717@qq.com * @created 2018/8/20 上午10:37. */public interface Element &#123; void accept(Visitor visitor);&#125; 5. Element实现类ConcreteElementA12345678910/** * @author 512573717@qq.com * @created 2018/8/20 上午10:37. */public class ConcreteElementA implements Element &#123; public void accept(Visitor visitor) &#123; System.out.println(visitor.getClass().getCanonicalName() + &quot;=====访问&quot; +&quot;ConcreteElementA&quot;); visitor.visit(this); &#125;&#125; 6. Element实现类ConcreteElementB12345678910/** * @author 512573717@qq.com * @created 2018/8/20 上午10:37. */public class ConcreteElementB implements Element &#123; public void accept(Visitor visitor) &#123; System.out.println(visitor.getClass().getCanonicalName() + &quot;=======访问&quot;+ &quot;ConcreteElementB&quot;); visitor.visit(this); &#125;&#125; 7. ObjectStructure123456789101112131415161718192021/** * @author 512573717@qq.com * @created 2018/8/20 上午10:39. */public class ObjectStructure &#123; private List&lt;Element&gt; mElements = new ArrayList&lt;&gt;(); public void addElement(Element e) &#123; mElements.add(e); &#125; public void removeElement(Element e) &#123; mElements.remove(e); &#125; public void accpet(Visitor visitor) &#123; for (Element e : mElements) &#123; e.accept(visitor); &#125; &#125;&#125; 8. Client123456ObjectStructure os = new ObjectStructure();os.addElement(new ConcreteElementA());os.addElement(new ConcreteElementB());//创建一个访问者Visitor visitor = new ConcreteVisitorA();os.accpet(visitor); 访问者模式中的伪动态双分派 静态分派 &emsp;&emsp;静态分派就是按照变量的静态类型进行分派，从而确定方法的执行版本，静态分派在编译时期就可以确定方法的版本。静态分派最典型的应用就是方法重载。123456789101112131415161718public class StaticDispatch &#123; public void test(String string)&#123; System.out.println(&quot;this is string&quot;); &#125; public void test(Integer integer)&#123; System.out.println(&quot;this is integer&quot;); &#125; public static void staticDispatch(String[] args) &#123; String s1 =&quot;aaaaa&quot;; Integer a = 1; StaticDispatch staticDispatch = new StaticDispatch(); staticDispatch.test(a); staticDispatch.test(s1); &#125;&#125; 动态分派 &emsp;&emsp;与静态相反，它不是在编译期确定的方法版本，而是在运行时才能确定。而动态分派最典型的应用就是多态的特性。123456789101112131415161718192021222324public interface Animal&#123; void test();&#125;public class Dog implements Animal&#123; public void test()&#123; System.out.println(&quot;dog&quot;); &#125;&#125;public class Cat implements Animal&#123; public void test()&#123; System.out.println(&quot;cat&quot;); &#125;&#125;public class DynamicDispatch &#123; public static void main(String[] args) &#123; Animal dog = new Dog(); Animal cat = new Cat(); dog.test(); cat.test(); &#125;&#125; 伪动态双分派 &emsp;&emsp;访问者模式中使用的是伪动态双分派，所谓的动态双分派就是在运行时依据两个实际类型去判断一个方法的运行行为，而访问者模式实现的手段是进行了两次动态单分派来达到这个效果。 12345public void accpet(Visitor visitor) &#123; for (Element e : mElements) &#123; e.accept(visitor); &#125; &#125; 访问者模式实际运用1. Visitor1234567891011121314/** * Visitor * * @author 512573717@qq.com * @created 2018/8/20 下午12:46. */public interface AccountBookViewer &#123; //查看消费的单子 void view(ConsumeBill bill); //查看收入的单子 void view(IncomeBill bill);&#125; 2. 老板123456789101112131415161718192021222324252627282930313233/** * visitor 老板 * * @author 512573717@qq.com * @created 2018/8/20 下午12:47. * */public class Boss implements AccountBookViewer &#123; private double totalIncome; private double totalConsume; //老板只关注一共花了多少钱以及一共收入多少钱，其余并不关心 public void view(ConsumeBill bill) &#123; totalConsume += bill.getAmount(); &#125; public void view(IncomeBill bill) &#123; totalIncome += bill.getAmount(); &#125; public double getTotalIncome() &#123; System.out.println(&quot;老板查看一共收入多少，数目是：&quot; + totalIncome); return totalIncome; &#125; public double getTotalConsume() &#123; System.out.println(&quot;老板查看一共花费多少，数目是：&quot; + totalConsume); return totalConsume; &#125;&#125; 3. 会计1234567891011121314151617181920/** * visitor 会计 * * @author 512573717@qq.com * @created 2018/8/20 下午12:47. */public class CPA implements AccountBookViewer &#123; //注会在看账本时，如果是支出，则如果支出是工资，则需要看应该交的税交了没 public void view(ConsumeBill bill) &#123; if (bill.getItem().equals(&quot;工资&quot;)) &#123; System.out.println(&quot;注会查看工资是否交个人所得税。&quot;); &#125; &#125; //如果是收入，则所有的收入都要交税 public void view(IncomeBill bill) &#123; System.out.println(&quot;注会查看收入交税了没。&quot;); &#125;&#125; 4. Element123456789/** * Element * * @author 512573717@qq.com * @created 2018/8/20 下午12:49. */public interface Bill &#123; void accept(AccountBookViewer viewer);&#125; 5. 消费123456789101112131415161718192021222324252627282930/** * 消费 * * @author 512573717@qq.com * @created 2018/8/20 下午12:50. */public class ConsumeBill implements Bill &#123; private double amount; private String item; public ConsumeBill(double amount, String item) &#123; super(); this.amount = amount; this.item = item; &#125; public void accept(AccountBookViewer viewer) &#123; viewer.view(this); &#125; public double getAmount() &#123; return amount; &#125; public String getItem() &#123; return item; &#125;&#125; 6. 收入的单子12345678910111213141516171819202122232425262728293031/** * 收入的单子 * * @author 512573717@qq.com * @created 2018/8/20 下午12:51. */public class IncomeBill implements Bill&#123; private double amount; private String item; public IncomeBill(double amount, String item) &#123; super(); this.amount = amount; this.item = item; &#125; public void accept(AccountBookViewer viewer) &#123; viewer.view(this); &#125; public double getAmount() &#123; return amount; &#125; public String getItem() &#123; return item; &#125;&#125; 7. 账簿1234567891011121314151617181920212223/** * ObjectStruture * * @author 512573717@qq.com * @created 2018/8/20 下午12:52. */public class AccountBook &#123; //单子列表 private List&lt;Bill&gt; billList = new ArrayList&lt;Bill&gt;(); //添加单子 public void addBill(Bill bill) &#123; billList.add(bill); &#125; //供账本的查看者查看账本 public void show(AccountBookViewer viewer) &#123; for (Bill bill : billList) &#123; bill.accept(viewer); &#125; &#125;&#125; 8. Client123456789101112131415AccountBook accountBook = new AccountBook();//添加收入accountBook.addBill(new IncomeBill(10000, &quot;卖商品&quot;));//添加支出accountBook.addBill(new ConsumeBill(1000, &quot;工资&quot;));AccountBookViewer boss = new Boss();AccountBookViewer cpa = new CPA();//两个访问者分别访问账本accountBook.show(cpa);accountBook.show(boss);((Boss) boss).getTotalConsume();((Boss) boss).getTotalIncome(); 总结 优点 使得对象结构和作用于结构上的操作解耦，使得操作集合可以独立变化。添加新的操作或者说访问者会非常容易，无须修改源代码，符合“开闭原则”。 将有关元素对象的操作集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。 使得类层次结构不改变的情况下，可以针对各个层次做出不同的操作，而不影响类层次结构的完整性。 可以跨越类层次结构，访问不同层次的元素类，做出相应的操作。 缺点 增加新的元素会非常困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求。 实现起来比较复杂，会增加系统的复杂性。 破坏封装，如果将访问行为放在各个元素中，则可以不暴露元素的内部结构和状态，但使用访问者模式的时候，为了让访问者能获取到所关心的信息，元素类不得不暴露出一些内部的状态和结构。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式《责任链模式》]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[引言&emsp;&emsp;上一章我们将了代理模式，这一节我们说说责任链模式，目前的这几种模式都是比较简单的。 示例地址 &emsp;&emsp;Demo地址 类图 定义&emsp;&emsp;使多个对象都有机会处理请求,从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，只到有对象处理它为止。 责任链模式使用场景&emsp;&emsp;1. 多个对象可以处理同一请求，但具体由那个对象处理则在运行时动态决定。&emsp;&emsp;2. 在请求处理者不明确的情况下向多个对象中的一个提交。&emsp;&emsp;3. 需要动态指定一组对象处理请求。 责任链模式示例&emsp;&emsp;在古代，小百姓打官司都是先到知县，不合理到知府，然后巡抚。 1. 先定义一个当官的接口，他们有权利处理老百姓的告状1234567891011121314151617181920/** * 有权利的人 * * @author 512573717@qq.com * @created 2018/7/19 下午4:11. */public abstract class DangGuan &#123; private DangGuan nextDangGuan; public DangGuan getNextDangGuan() &#123; return nextDangGuan; &#125; public void setNextDangGuan(DangGuan nextDangGuan) &#123; this.nextDangGuan = nextDangGuan; &#125; //案情 abstract void anQing(String desc);&#125; 2. 知县1234567891011121314151617/** * 知县 * * @author 512573717@qq.com * @created 2018/7/19 下午4:39. */public class CountyGuan extends DangGuan &#123; @Override void anQing(String desc) &#123; if (desc.equals(&quot;知县&quot;)) &#123; System.out.println(&quot;知县处理了此案情&quot;); &#125; else &#123; System.out.println(&quot;知县：这案情我处理不了，我先上报&quot;); getNextDangGuan().anQing(desc); &#125; &#125;&#125; 3. 知府1234567891011121314151617/** * 知府 * * @author 512573717@qq.com * @created 2018/7/19 下午4:43. */public class CityGuan extends DangGuan &#123; @Override void anQing(String desc) &#123; if (desc.equals(&quot;知府&quot;)) &#123; System.out.println(&quot;知府处理了此案情&quot;); &#125; else &#123; System.out.println(&quot;知府：这案情我处理不了，我先上报&quot;); getNextDangGuan().anQing(desc); &#125; &#125;&#125; 4. 巡抚12345678910111213141516/** * 巡抚 * * @author 512573717@qq.com * @created 2018/7/19 下午4:44. */public class ProvinceGuan extends DangGuan &#123; @Override void anQing(String desc) &#123; if (desc.equals(&quot;巡抚&quot;)) &#123; System.out.println(&quot;巡抚处理了此案情&quot;); &#125; else &#123; getNextDangGuan().anQing(desc); &#125; &#125;&#125; 5. 老百姓告状123456789CountyGuan countyGuan = new CountyGuan();CityGuan cityGuan = new CityGuan();ProvinceGuan provinceGuan = new ProvinceGuan();countyGuan.setNextDangGuan(cityGuan);cityGuan.setNextDangGuan(provinceGuan);System.out.println(&quot;老百姓开始告状了。&quot;);countyGuan.anQing(&quot;巡抚&quot;); 总结&emsp;&emsp;职责链的模式链的组成：&emsp;&emsp;第一步需要在处理者对象类中定义后继处理者对象，将这部分代码抽象到抽象类中实现，降低了代码重复性。&emsp;&emsp;第二步就是在处理者对象类中的处理方法中如果当前处理者对象无法处理，就将其传递到后继对象去处理。&emsp;&emsp;第三步就是在测试类中将这些处理者类的实例串联成链。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式《单例模式》]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[引言&emsp;&emsp;”送人玫瑰，手有余香”。最近在看设计模式，写点笔记记录一下，第一可以巩固一下所看的知道，第二方便他人阅读参考。从最简单的入手吧，今天的主角单例模式。 示例地址&emsp;&emsp;Demo 先看看单例模式的类图 再看看单例模式的定义&emsp;&emsp;确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 使用场景&emsp;&emsp;确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源。 单例模式主要表现1. 构造方法私有 2. 通过一个静态方法返回改对象 单例模式示例1. 饿汉式1234567891011121314151617/** * 单例 饿汉式 * * @author 512573717@qq.com * @created 2018/7/2 下午1:59. */public class Singleton &#123; private static Singleton mInstance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return mInstance; &#125;&#125; 2. 懒汉式1234567891011121314151617181920212223242526272829/** * 单例 懒汉式 * * @author 512573717@qq.com * @created 2018/7/2 下午1:59. */public class Singleton &#123; //synchronized虽然保证了原子性，但却没有保证指令重排序的正确性，会出现A线程执行初始化， // 但可能因为构造函数里面的操作太多了，所以A线程的uniqueInstance实例还没有造出来，但已经被赋值了。 // 而B线程这时过来了，错以为uniqueInstance已经被实例化出来，一用才发现uniqueInstance尚未被初始化。 // 要知道我们的线程虽然可以保证原子性，但程序可能是在多核CPU上执行。 // volatile http://www.cnblogs.com/dolphin0520/p/3920373.html private static volatile Singleton mInstance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (null == mInstance) &#123; // 防止 多线程并发 创建多个实例 synchronized (Singleton.class) &#123; if (null == mInstance) &#123; mInstance = new Singleton(); &#125; &#125; &#125; return mInstance; &#125;&#125; 3. 静态内部类12345678910111213141516171819/** * 单例 静态内部类 * * @author 512573717@qq.com * @created 2018/7/2 下午1:59. */public class Singleton &#123; private Singleton() &#123; &#125; public static class SingletonHolder&#123; private static volatile Singleton mInstance = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHolder.mInstance; &#125;&#125; 4. 容器管理123456789101112131415161718192021/** * 单例 容器管理 * * @author 512573717@qq.com * @created 2018/7/2 下午1:59. */public class Singleton &#123; private static Map&lt;String, Object&gt; mSingleMap = new HashMap&lt;&gt;(); private Singleton()&#123; &#125; static &#123; mSingleMap.put(&quot;service&quot;, new Singleton()); &#125; public static Object getServiceForName(String name) &#123; return mSingleMap.get(name); &#125;&#125; 5. 其他体现形式123456789101112131415161718192021/** * 单例 其他体现形式 * @author 512573717@qq.com * @created 2018/7/2 下午1:59. */public class Singleton &#123; private static Singleton mInstance; private Singleton() &#123; &#125; static &#123; mInstance = new Singleton(); &#125; public static Object getInstance() &#123; return mInstance; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式开篇《六大原则》]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87%E3%80%8A%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E3%80%8B%2F</url>
    <content type="text"><![CDATA[目录&emsp;&emsp;创建型模式 单例模式 工厂方法模式 抽象工厂模式 原型模式 建造者模式 &emsp;&emsp;结构型模式 代理模式 适配器模式 装饰模式 桥接模式 组合模式 享元模式 外观模式 &emsp;&emsp;行为型模式 模板方法模式 策略模式 状态模式 观察者模式 责任链模式 中介者模式 备忘录模式 命令模式 解释器模式 访问者模式 迭代器模式 一、单一职责原则定义&emsp;&emsp;一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。简单来说，一个类中应该是一组相关性很高的函数、数据的封装。 1. 一般我们写一个网络请求可能是这样123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class HttpUtils &#123; private HttpUtils() &#123; &#125; public static &lt;T&gt; void get(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback, final boolean cache) &#123; OkHttpClient mOkHttpClient = new OkHttpClient(); // 公共参数 params.put(&quot;app_name&quot;, &quot;joke_essay&quot;); params.put(&quot;version_name&quot;, &quot;5.7.0&quot;); params.put(&quot;device_platform&quot;, &quot;android&quot;); final String jointUrl = Utils.jointParams(url, params); //打印 // 缓存问题 Log.e(&quot;Post请求路径：&quot;, jointUrl); // 缓存写到 SP 里面，多级缓存（内存中 30条,数据库 ，文件中 ） final String cacheJson = (String) PreferencesUtil.getInstance().getParam(jointUrl, &quot;&quot;); // 写一大堆处理逻辑 ，内存怎么扩展等等 if (cache &amp;&amp; !TextUtils.isEmpty(cacheJson)) &#123; Log.e(&quot;TAG&quot;, &quot;从缓存中获取数据&quot;); Gson gson = new Gson(); T objResult = (T) gson.fromJson(cacheJson, Utils.analysisClazzInfo(callback)); callback.onSuccess(objResult); return; &#125; Request.Builder requestBuilder = new Request.Builder().url(jointUrl).tag(context); //可以省略，默认是GET请求 Request request = requestBuilder.build(); mOkHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, final IOException e) &#123; // 失败 callback.onFailure(e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; final String resultJson = response.body().string(); Log.e(&quot;TAG&quot;, resultJson.equals(cacheJson) + &quot;&quot;); Log.e(&quot;TAG&quot;, resultJson + &quot;&quot;); if (cache &amp;&amp; resultJson.equals(cacheJson)) &#123; return; &#125; Gson gson = new Gson(); T objResult = (T) gson.fromJson(resultJson, Utils.analysisClazzInfo(callback)); callback.onSuccess(objResult); if (cache) &#123; PreferencesUtil.getInstance().saveParam(jointUrl, resultJson); &#125; &#125; &#125;); &#125;&#125; 2. 然后这样调用1234567891011121314151617181920212223Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); // 特定参数 params.put(&quot;iid&quot;, 6152551759L); params.put(&quot;aid&quot;, 7); HttpUtils.get(this, ConstantValue.UrlConstant.HOME_DISCOVERY_URL, params, new HttpCallBack&lt;DiscoverListResult&gt;() &#123; @Override public void onFailure(Exception e) &#123; // 失败 &#125; @Override public void onSuccess(DiscoverListResult result)&#123; if (result.isOK()) &#123; // 没有列表数据的情况, 打印 Toast 或者做一些其他处理 &#125; else &#123; // 有数据列表的情况，显示列表 showListData(result); &#125; &#125; &#125;,true); 3. 导致问题&emsp;&emsp;所有的功能都写在一个类里，这样随着功能的增多，HttpUtils 类会越来越大，代码也越来越复杂。HttpUtils简直就没有设计可言，更不要说扩展性、灵活性了。 4. 单一职责原则入场&emsp;&emsp;我们将HttpUtils进行拆分，一个类只负责一个职责。 5. HttpUtils123456789101112131415public class HttpUtils &#123; private OKHttpRequest mHttpRequest; public &lt;T&gt; void request() &#123; request(null); &#125; public &lt;T&gt; void request(final HttpCallBack&lt;T&gt; callback) &#123; // 异常判断 mHttpRequest.get(mContext, mUrl, mParams, callback, true); &#125; //省略其他代码&#125; 6. OKHttpRequest12345678910111213141516public class OKHttpRequest &#123; private HttpCache mHttpCache; public OKHttpRequest() &#123; mHttpCache = new HttpCache(); &#125; // 参数还是很多 public &lt;T&gt; void get(Context context, String url, Map&lt;String, Object&gt; params,final HttpCallBack&lt;T&gt; callback, final boolean cache) &#123; OkHttpClient mOkHttpClient = new OkHttpClient(); &#125; //省略其他代码&#125; 7. HttpCache123456789public class HttpCache &#123; public void saveCache(String finalUrl, String resultJson) &#123; PreferencesUtil.getInstance().saveParam(finalUrl, resultJson); &#125; public String getCache(String finalUrl) &#123; return (String) PreferencesUtil.getInstance().getParam(finalUrl, &quot;&quot;); &#125;&#125; 二、开闭原则定义&emsp;&emsp;软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的。我的理解是对于原来写好的代码里面是不可修改，但是对于外部又是可扩展的。其实就是多了一个接口而已。 1. 上面代码存在问题&emsp;&emsp;如果把xutils换成OkHttp，但是我没想过要去改每个接口，比如后来接着 Retrofit又出来了，以后还指不定要出一些什么，我想能不能再写得强大一些，可以切换，而不用改动原来的代码。 2. 修改后的类图 3. 开闭原则入场&emsp;&emsp;新增IHttpRequest接口123456789101112131415161718/** * @author 512573717@qq.com * @created 2018/8/22 上午10:49. */public interface IHttpRequest &#123; &lt;T&gt; void get(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback, final boolean cache); &lt;T&gt; void post(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback, final boolean cache); &lt;T&gt; void download(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback); &lt;T&gt; void upload(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback);&#125; 4. XUtilsRequest123456789101112131415public class XUtilsRequest implements IHttpRequest &#123; private SPHttpCache mHttpCache; public XUtilsRequest() &#123; mHttpCache = new SPHttpCache(); &#125; // 参数还是很多 public &lt;T&gt; void get(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback, final boolean cache) &#123; RequestParams requestParams = new RequestParams(); x.http().get(requestParams, new org.xutils.common.Callback.CommonCallback&lt;String&gt;() &#123; &#125;); &#125; 5. OKHttpRequest123456789101112131415public class OKHttpRequest implements IHttpRequest&#123; private SPHttpCache mHttpCache; public OKHttpRequest() &#123; mHttpCache = new SPHttpCache(); &#125; // 参数还是很多 public &lt;T&gt; void get(Context context, String url, Map&lt;String, Object&gt; params, final HttpCallBack&lt;T&gt; callback, final boolean cache) &#123; OkHttpClient mOkHttpClient = new OkHttpClient(); &#125;&#125; 6. HttpUtils1234567891011121314151617181920212223242526public class HttpUtils &#123; private IHttpRequest mHttpRequest; private static IHttpRequest mInitHttpRequest; public static HttpUtils with(Context context)&#123; return new HttpUtils(context); &#125; public HttpUtils httpRequest(IHttpRequest httpRequest)&#123; mHttpRequest = httpRequest; return this; &#125; public &lt;T&gt; void request()&#123; request(null); &#125; public &lt;T&gt; void request(final HttpCallBack&lt;T&gt; callback)&#123; if(mHttpRequest == null)&#123; mHttpRequest = mInitHttpRequest; &#125; // 异常判断 mHttpRequest.get(mContext,mUrl,mParams,callback,true); &#125; &#125; 7. Client12345678910111213141516171819HttpUtils.with(this).cache(true).get().httpRequest(new OKHttpRequest()).url(ConstantValue.UrlConstant.HOME_DISCOVERY_URL).param(&quot;iid&quot;, 6152551759L).param(&quot;aid&quot;, 7).request( new HttpCallBack&lt;DiscoverListResult&gt;() &#123; @Override public void onFailure(Exception e) &#123; // 失败 &#125; @Override public void onSuccess(DiscoverListResult result)&#123; if (result.isOK()) &#123; // 没有列表数据的情况, 打印 Toast 或者做一些其他处理 &#125; else &#123; // 有数据列表的情况，显示列表 showListData(result); &#125; &#125; &#125;); 8. 归纳&emsp;&emsp;当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。我们尽量不要通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。 三、里氏替换原则定义&emsp;&emsp;所有引用基类的地方必须能透明地使用其子类的对象。通俗点讲，只要父类能出现的地方子类就可以出现。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。 代码体现12HttpUtils.initHttpRequest(new OKHttpRequest());HttpUtils.initHttpRequest(new XUtilsRequest()); 四、依赖倒置原则定义&emsp;&emsp;依赖反转原则指代了一种特定的解耦形式，高层模块不依赖低层次模块的细节，说白了高层次就是不依赖细节而是依赖抽象。 1. 刚开始代码是这样写的123456789public class HttpUtils &#123; private OKHttpRequest mHttpRequest; private HttpUtils(Context context) &#123; mHttpRequest = new OKHttpRequest(); mParams = new HashMap&lt;&gt;(); this.mContext = context; &#125;&#125; 2. 用过开闭原则之后是这样写的123456789101112public class HttpUtils &#123; private IHttpRequest mHttpRequest; public static HttpUtils with(Context context)&#123; return new HttpUtils(context); &#125; public HttpUtils httpRequest(IHttpRequest httpRequest)&#123; mHttpRequest = httpRequest; return this; &#125;&#125; 3. 总结&emsp;&emsp;这个时候我们依赖的就已经不在是具体的细节了，而是抽象的 IHttpRequest ，具体的实现我们是在 Application 中配置的，可以配置 Okhttp 或者 xUtils 等等。从上面这几个来看要让整个系统更加灵活，似乎一直都是抽象的功劳。 五、接口隔离原则定义&emsp;&emsp;客户端不应该依赖它不需要的接口。另一种定义是：类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署，让客户端依赖的接口尽可能地小。 1. 我们在关闭文件流、Socket流通常是这样操作的12345678910111213141516171819202122232425262728private void breakConnection() &#123; mReadFlag = false; // 关闭输入流 if (mInStream != null) &#123; try &#123; mInStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 关闭输出流 if (mOutStream != null) &#123; try &#123; mOutStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 关闭Socket if (mSocket != null) &#123; try &#123; mSocket.close(); mSocket = null; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &emsp;&emsp;各种try…catch嵌套，都是些简单的代码，但是会严重影响代码的可读性，并且多层级的大括号很容易将代码写到错误的层级中。大家应该对这类代码也非常反感，那我们看看如何解决这类问题。我们看源码发现他们都有一个 close 方法，而且这个方法是 Closeable 接口的，也就是说上面的这几个类都是实现了 Closeable 接口，该接口标识了一个可关闭的对象。 2.都实现了Closeable接口1234567891011public abstract class InputStream implements Closeable &#123; &#125;public abstract class OutputStream implements Closeable, Flushable &#123; &#125;public class Socket implements java.io.Closeable &#123; &#125; 3. Closeable1234567891011121314151617public interface Closeable extends AutoCloseable &#123; /** * Closes this stream and releases any system resources associated * with it. If the stream is already closed then invoking this * method has no effect. * * &lt;p&gt; As noted in &#123;@link AutoCloseable#close()&#125;, cases where the * close may fail require careful attention. It is strongly advised * to relinquish the underlying resources and to internally * &lt;em&gt;mark&lt;/em&gt; the &#123;@code Closeable&#125; as closed, prior to throwing * the &#123;@code IOException&#125;. * * @throws IOException if an I/O error occurs */ public void close() throws IOException;&#125; 4. 修改代码1234567891011121314151617181920212223private void breakConnection() &#123; mReadFlag = false; // 关闭输入流 close(mInStream); // 关闭输出流 close(mOutStream); // 关闭Socket close(mSocket);&#125;/*** 关闭 Closeable* @param closeable*/private void close(Closeable closeable) &#123; if (closeable != null) &#123; try &#123; closeable.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5. 总结&emsp;&emsp;代码简洁了很多！保证了代码的重用性。close 方法的基本原理就是依赖于 Closeable 抽象而不是具体实现（这其实也是依赖倒置），并且建立在最小化依赖原则的基础，它只需要知道这个对象是可关闭，其他的一概不关心，也就是这里的接口隔离原则。 六、最少知识原则定义&emsp;&emsp;一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 示例地址&emsp;&emsp;Demo]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
</search>
